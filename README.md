TUGAS 7
1. Widget tree merupakan representasi hierarki dari semua widget yang kita gunakan untuk membuat UI pada aplikasi kita. Pada Widget Tree akan terdiri dari Root Widget yang biasanya adalah MaterialApp. Setelah itu, ada child atau children yang bisa memiliki anak lagi. Widget pada level terluar terdiri dari Scaffold, Column, dan Row. Widget pada level terdalam terdiri dari Text, Icon, Image. Hubungan parent-chid, Widget Parent merupakan widget yang mengandung widget lain, contohnya column adalah parent dari widget yang ada didalamnya. Sedangkan, Widget Child merupakan widget yang ada di dalam parent. Parent akan bertanggung jawab untuk mengatur posisi dan ukuran dari childnya. Dalam Tugas ini juga bisa dilihat kalau parent menyusun agar semua childrennya berjejer secara horizontal maupun vertikal.

2. MyApp (StatelessWidget) yang merupakan root widget aplikasi saya yang berfungsi untuk menginisialisasi aplikasi dan mengembalikan MaterialApp. MyHomePage (StatelessWidget) ynag merupakan widget untuk halaman utama di menu.dart yang berfungsi untuk membangun Scaffold yang berisi AppBar dan body. ItemCard (StatelessWidget) yang berfungsi untuk menampilkan satu item dalam GridView. Fungsinya adalah menampilkan icon dan text dalam sebuah Material yang bisa diklik untuk memunculkan SnackBar. MaterialApp yang berfungsi untuk mengatur tema global, judul, dan menentukan halaman awal. Scaffold berfungsi untuk menyediakan struktur halaman dasar. AppBar berfungsi untuk menampilkan text pada bagian atas layar. Padding yang digunakan untuk membungkus Column utama di body serta membungkus text. Column berfungsi untuk menyusun widget-widget childrennya secara vertikal. SizedBox digunakan untuk membuat kotak kosong sebagai pemberi jarak. Center untuk memposisikan column di tengah. GridView.count berfungsi untuk menyusun ItemCard dalam grid yang dapat discroll. Material berfungsi sebagai kanvas dasar untuk ItemCard yang saya beri backgroundColor dan borderRadius. InkWell berfungsi untuk membungkus Container agar dapat diklik. SnackBar adalah widget yang muncul sementara di bagian bawah sebagai pesan popup ketika ItemCard diklik. Icon untuk menampilkan ikon.

3. MaterialApp merupakan sebuah widget yang menyediakan berbagai fungsi seperti navigasi, theme, Lokal, dan menentukan halaman awal. Widget ini sering digunakan sebagai root karena menyediakan semua layanan penting ke seluruh widget yang ada dibawahnya dalam widget tree. Tanpa MaterialApp sebagai parent, maka widget laiin seperti Navigator atau Theme tidak akan berfungsi dengan baik.

4. StatelessWidget merupakan widget yang tidak memiliki state internal yang bisa berubah. StatelessWidget digunakan ketika tampilan widget tidak akan pernah berubah, kecuali parentnya memerintahkannya utnuk berubah. Hal ini tentu berpengaruh ke peforma yang lebih baik. Sedangkan StatefulWidget merupakan widget yang memiliki state internal yang dapat berubah selama siklus widget tersebut. StatefulWidget digunakan ketika UI widget perlu berubah secara dinamis sebagai respon terhadap interaksi dengan user, data yang masuk maupun animasi.

5. BuildContext seperti alamat sebuah widget di dalam widget tree. Setiap widget akan memiliki BuildContextnya sendiri-sendiri yang menunjukkan dimana posisinya terhadap widget lain. Ini sangat penting karena BuildContext merupakan acuan yang digunakan widget untuk berinteraksi dengan tree diatasnya. Fungsi utamanya adalah untuk mencari widget tertentu yang berada di level parent atau yang lebih tinggi. Untuk penggunannya biasa adalah dengan menggunakan method .of() seperti Theme.of(context) yang berarti tolong cara ThemeData terdekat yang ada di atas dan masih banyak lagi.

6. Hot Reload akan memuat ulang perubahan kode kita secara instan tanpa kehilangan state aplikasi. Sedangkan hot restart akan memuat ulang aplikasi dengan melakukan reset semua state kembali ke awal.

TUGAS 8
1. Navigator.push() akan menambahkan halaman baru "diatas" halaman saat ini pada tumpukan navigasi. Jadi halaman sebelumnya tetap ada di dalam tumpukan dan pengguna bisa menekan tombol back di aplikasi maupun tombol pada android untuk kembali ke halaman sebelumnya. Ini digunakan ketika pengguna ingin masuk lebih dalam ke sebuah konten. Contohnya ketika menekan tombol Create Product di halaman utama, kita dapat menggunakannya untuk membuka Product Form Page dan pengguna diharapkan bisa kembali ke halaman utama setelah selesai. Navigator.pushReplacement() akan mengganti halaman saat ini di tumpukan navigasi dengan halaman baru. Halaman sebelumnya akan dihapus dari tumpukan sehingga pengguna tidak bisa menekan tombol back untuk kembali ke halaman tersebut. Ini digunakan ketika kita ingin pindah ke halaman baru tanpa ada niat untuk kembali ke halaman sebelumnya. Contohnya pada drawer ketika pengguna menekan opsi halaman utama. Jika pengguna saat ini berada di halaman tambah produk dan menekan halaman utama, kita menggunakan .pushReplacement sehingga secara tidak langsung akan mereset tumpukan navigasi

2. Scaffold adalah "kerangka" dasar untuk setiap halaman Material Design. Ia menyediakan "slot" terstruktur untuk elemen-elemen umum seperti appBar, body, drawer, dan floatingActionButton. Dengan menggunakan Scaffold sebagai widget teratas di setiap halaman (seperti di MyHomePage dan ProductFormPage), kita memastikan bahwa setiap halaman memiliki struktur dasar yang sama.

AppBar ditempatkan di slot appBar milik Scaffold. Ini secara otomatis menempatkannya di bagian atas layar dengan layout dan style yang konsisten. Scaffold juga secara otomatis menambahkan tombol "Back" pada AppBar jika halaman itu dibuka menggunakan Navigator.push(), dan menambahkan tombol "hamburger" (menu) jika sebuah Drawer dipasang.

Drawer ditempatkan di slot drawer milik Scaffold. Scaffold menangani semua logika kompleks untuk memunculkan dan menyembunyikan drawer.

Untuk aplikasi ini, saya membuat sebuah widget kostum terpisah bernama LeftDrawer (left_drawer.dart). Widget ini mendefinisikan semua ListTile dan onTap untuk navigasi. Kemudian, di setiap halaman (MyHomePage dan ProductFormPage), saya hanya perlu menambahkan satu baris kode di dalam Scaffold. Dengan melakukan ini, kedua halaman tersebut dijamin memiliki drawer yang 100% identik. Jika saya perlu menambahkan menu baru di drawer (misalnya "Halaman Profil"), saya hanya perlu mengedit satu file (left_drawer.dart), dan perubahan itu akan otomatis diterapkan di seluruh aplikasi. Inilah kekuatan dari komposisi dan hirarki widget.

3. Padding memberikan ruang di sekitar elemen-elemen pada form. Tanpa padding, TextFormField atau button akan saling menempel satu sama lain dan terlihat berantakan. Saya menggunakannya di ProductFormPage, di mana saya membungkus seluruh kolom yang berisi form dengan Padding(padding: const EdgeInsets.all(16.0)) sehingga akan memberi jarak 16px di sekeliling seluruh form dari tepi layar.

SingleChildScrollView merupakan widget yang sangat berguna untuk form. Ketika penngguna menekan TextFromField, keyboard virtual akan muncul dan menutupi setengah bagian bawah layar. Tanpa ini, form yang panjang akan terpotong sehingga pengguna tidak bisa melihat apa yang mereka ketik. SingleChildScrollView membuat konten didalamnya dapat di scroll. Saya menggunakannya juga di ProductFormPage dengan membungkus padding yang berisi column dan form dengan SingleChildScrollView. Ini memastikan bahwa meskipun keyboard muncul, user selalu dapat melakukan scroll untuk mengakses semua field input dan tombol

ListView mirip dengan SingleChildScrollView, menyediakan kemampuan scrolling. Kelebihannya adalah lebih dioptimalkan untuk daftar yang sangat panjang dan dinamis. Saya menggunakan SingleChildScrollView dan Column untuk form ini karena jumlahnya tetap dan statis. Tetapi bisa digantikan dengan ListView juga, hanya perlu mengganti SingleChildScrollView(child: Column(children: ...)) dengan ListView(padding: const EdgeInsets.all(16.0), children: ...). Hasilnya akan tetap sama.

4. Saya menggunakan tema global untuk seluruh aplikasi yang dibuat dalam widget MaterialApp menggunakan properti ThemeData. Didalamnya saya menggunakan colorScheme untuk mengatur palet warna. Jika aplikasi yang saya bikin memiliki warna utama yaitu ungu, saya hanya perlu mengubah ColorSchemenya menjadi ungu dan seluruh aplikasi akan berubah. Widget lain di aplikasi tidak menggunakan warna secara hardcodo, saya mengambil warna dari tema global tersebut menggunakan Theme.of(context). Ini akan memastikan warna tetap konsisten karena jika saya mengubah tema pada main.dart, semua Appbar di aplikasi saya juga akan otomatis ikut berubah

TUGAS 9
1. Kita perlu membuat model Dart untuk menjamin Type Safety dan Struktur Data yang Konsisten. Model memaksa kita mendefinisikan tipe data (misalnya int, String, DateTime) untuk setiap field. Ini membantu menangkap kesalahan tipe data saat kompilasi (compile-time), bukan saat aplikasi berjalan (runtime). Konsekuensi Tanpa Model adalah Rawan Error karena Kita harus mengetik nama key secara manual (misalnya data['price']). Jika salah ketik (misalnya data['prce']), aplikasi akan error saat dijalankan tanpa peringatan sebelumnya. Tidak Ada Type Safety karena nilai dianggap sebagai dynamic. Kita bisa tidak sengaja melakukan operasi matematika pada String, yang akan menyebabkan aplikasi crash. Sulit untuk dimaintain karena jika struktur JSON dari backend berubah, kita harus mencari dan mengubah setiap bagian kode yang mengakses Map tersebut satu per satu. Dengan model, kita cukup mengubah definisi kelas modelnya saja.

2. HTTP adalah library di Dart untuk melakukan permintaan HTTP standar seperti GET, POST, PUT, dan DELETE. Fungsinya adalah membuka koneksi jaringan ke server dan mengirim/menerima data mentah. Namun, package ini stateless, artinya ia tidak secara otomatis menyimpan data sesi (cookies) antar permintaan. Package pbp_django_auth (CookieRequest) adalah wrapper di atas package http yang dirancang khusus untuk menangani autentikasi berbasis sesi (session-based authentication) dengan Django. Berguna untuk menyimpan cookies (seperti sessionid dan csrftoken) yang dikirim oleh server Django setelah login berhasil. Setiap kali kita melakukan request berikutnya (misalnya mengambil daftar produk), CookieRequest akan otomatis menyertakan cookies tersebut di header permintaan. HTTP hanyalah alat transportasi data. Jika kita login menggunakan http biasa, server akan memberikan cookie, tapi http akan melupakannya di request selanjutnya, sehingga kita dianggap "belum login" lagi. CookieRequest adalah Alat transportasi data plus dompet untuk menyimpan "kartu identitas" (cookie). Ia memastikan server tahu bahwa request kedua, ketiga, dst. berasal dari pengguna yang sama yang sudah login.

3. Instance CookieRequest perlu dibagikan karena menyimpan State Login pengguna (session cookies). Jika kita membuat instance CookieRequest baru di setiap halaman (misalnya CookieRequest req = CookieRequest() di halaman Login, dan buat baru lagi di halaman Daftar Produk), maka instance baru tersebut kosong yang akibatnya Pengguna login di halaman Login (Instance A menyimpan cookie). Pengguna pindah ke halaman Daftar Produk (Instance B dibuat baru, cookie kosong). Saat Instance B meminta data ke Django, Django menolak karena tidak menemukan cookie sesi di Instance B. Dengan membagikan satu instance yang sama ke seluruh aplikasi (lewat Provider di main.dart), semua halaman (Login, Register, List, Form) mengakses "dompet cookie" yang sama, sehingga status login terjaga konsisten di seluruh aplikasi.

4. Agar aplikasi Flutter bisa bicara dengan server Django di laptop, diperlukan konfigurasi ALLOWED_HOSTS di Django (settings.py): Kita harus menambahkan 10.0.2.2, localhost, dan 127.0.0.1. Secara default, Django memblokir request dari host yang tidak dikenal demi keamanan. Emulator Android menggunakan IP spesial 10.0.2.2 untuk merujuk ke localhost komputer host (laptop kita). Jika IP ini tidak didaftarkan, Django akan menolak koneksi (Error DisallowedHost). django-cors-headers diperlukan terutama jika kita menjalankan Flutter Web. Ini memberi tahu browser/klien bahwa server Django mengizinkan permintaan dari domain/port yang berbeda (misalnya Flutter berjalan di port berbeda dari Django). Tanpa ini, browser akan memblokir request demi keamanan. android.permission.INTERNET,Kita harus menambahkan <uses-permission android:name="android.permission.INTERNET" /> di AndroidManifest.xml Android memiliki sistem keamanan berbasis izin. Aplikasi tidak boleh mengakses internet tanpa deklarasi eksplisit ini. Jika lupa, aplikasi akan mengalami SocketException: Permission denied.

5. Pengguna mengisi data (Nama, Harga, dll) pada TextFormField di halaman ProductFormPage. Data ini disimpan sementara oleh TextEditingController. Saat tombol "Save" ditekan, data dari controller diambil dan diubah menjadi format JSON string menggunakan jsonEncode. CookieRequest mengirim data JSON tersebut menggunakan metode POST ke endpoint Django. Django menerima request. Fungsi view create_product_flutter membaca body request (request.body).Data JSON di-parse menjadi dictionary Python (json.loads). Django membuat objek model Product baru, mengisinya dengan data tersebut, dan menyimpannya ke database (.save()). Django mengirim balik respon JSON (misal: {"status": "success"}).
Flutter menerima respon sukses, Aplikasi menavigasi pengguna kembali ke halaman Daftar Produk (ProductEntryPage), Halaman Daftar Produk melakukan inisialisasi ulang dan memanggil fungsi fetchProduct. Fungsi fetchProduct mengirim request GET ke Django (/json/). Django mengirim daftar produk terbaru (termasuk yang baru ditambah) dalam format JSON. Flutter mengubahnya menjadi list objek Product dan menampilkannya di ListView.

6. Register
Flutter -> Pengguna input username/password -> Kirim POST ke /auth/register/.
Django -> Menerima data -> Cek apakah username sudah ada -> Jika tidak, buat User baru menggunakan User.objects.create_user (password di-hash otomatis) -> Simpan ke DB -> Kirim respon sukses.

Login
Flutter -> Pengguna input kredensial -> Kirim POST ke /auth/login/.
Django -> Menggunakan authenticate(username, password) untuk memverifikasi. Jika cocok, panggil login(request, user). Fungsi ini membuat Session ID di database server.
Django mengirim respon sukses beserta header Set-Cookie yang berisi sessionid.
Flutter -> CookieRequest menangkap header tersebut dan menyimpan cookie sessionid di memori lokal aplikasi. Status loggedIn menjadi true.

Filter
Setiap kali Flutter request data produk, CookieRequest menyertakan cookie sessionid. Django memvalidasi sesi tersebut, mengenali user (request.user), dan memfilter query database (Product.objects.filter(user=request.user)) sehingga user hanya melihat datanya sendiri.

Logout
Flutter -> Kirim request ke /auth/logout/.
Django -> Panggil logout(request) yang menghapus sesi aktif di database server.
Flutter -> CookieRequest menghapus cookie yang disimpannya. User kembali ke status anonymous.

7. Pertama-tama saya menyiapkan semua proses backend yang ada di Django terlebih dahulu mulai dari membuat app authentication, membuat semua fungsi yang dibutuhkan di views dan menyambungkannya dengan urls. Tidak lupa juga untuk mendownload django-cors-headers dan memasukkannya ke requirements.txt. Jangan lupa update settings.py terkait dengan authentication cors ke installed apps dan middleware. Setelah ini lanjut ke bagian frontendnya yaitu flutternya dengan membuat berbagai konfigurasi yang dibutuhkan seperti membuat model dari product, membuat beberapa file baru pada screens dan widgets untuk mendukung proses login, register, pengisian form, logout, dan juga proses fetching data dari django ke flutter. Setelah itu semua selesai, saya melakukan push untuk kedua repo tersebur.